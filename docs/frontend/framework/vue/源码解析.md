
## 为什么要学习Vue源码

1. 面试加分项
2. 提升技术水平
3. 学习源码设计模式
4. 学习源码设计思想
5. 学习源码设计技巧

## 模板引擎

### 数据改变视图

初始数据

```html
 <ul id="list"></ul>
```

```js
 const arr=[
    {
      name:'张三',
      age:18,
      sex:'人妖'
    },{
      name:'李四',
      age:18,
      sex:'人妖'
    },{
      name:'王五',
      age:18,
      sex:'人妖'
    }
  ]
```

1. DOM大法

```js
// 1. 获取标签
  const list=document.getElementById('list')
  const keys={
    name:'姓名',
    age:'年龄',
    sex:'性别'
  }
  // 遍历
  for (let i = 0; i < arr.length; i++) {
    // 创建li标签
    const oli=document.createElement('li')
    // 添加文本
    oli.innerText=arr[i].name+'的基本信息'
    // 添加类名
    oli.classList.add('hd')
    const bd=document.createElement('div')
    bd.classList.add('bd')
    for (let j = 0; j < Object.keys(arr[i]).length; j++) {
      const p=document.createElement('p')
      p.innerText=keys[Object.keys(arr[i])[j]]+':'+arr[i][Object.keys(arr[i])[j]]
      bd.appendChild(p)
    }
    // 在父元素尾部添加子元素
    oli.appendChild(bd)
    list.appendChild(oli)
  }
```

有此可见，使用dom去操作是相当的麻烦，而且代码的复用性非常差

2. 使用数组的`join`方法去实现

```js
const list=document.getElementById('list')
// 遍历
arr.forEach(item=>{
  const str=['<li>',item.name+'的基本信息<div class="bd"><p>姓名:',
  item.name,'</p><p>年龄:',item.age,'</p><p>性别:',item.sex,'</p></div></li>'].join('')
  list.innerHTML+=str;
})
```

3. 使用模板字符串去实现

```js
const list=document.getElementById('list')
arr.forEach=(item=>{
   const str=` <li class="hd">
                  ${item.name}的基本信息
                <div class="bd">
                  <p>姓名：${item.name}</p>
                  <p>年龄：${item.age}</p>
                  <p>性别：${item.sex}</p>
                </div>
              </li>
              `
  list.innerHTML+=str;
})
```

4. 模板引擎:`mustache`
mustache 是最早的模板引擎库，比 Vue 诞生早很多。它的底层实现机理在当时非常有创造性、轰动性、为后续模板引擎的发展提供了崭新的思路。

- 引用`mustache.js`

```html
<div id="container"></div>
<script src="https://unpkg.com/mustache@4.2.0/mustache.js"></script>
```

- 编写模板

```js
const template=`
                <ul>
                {{#arr}}
                  <li class="hd">
                    {{name}}的基本信息
                    <div class="db">
                        <p>姓名：{{name}}</p>
                        <p>年龄：{{age}}</p>
                        <p>性别：{{sex}}</p>
                    </div>
                  </li>
                {{/arr}}
                </ul>
                `
```

- 使用模板

```js
const t=Mustache.render(template,{arr:data});
document.getElementById('container').innerHTML=t
```

### mustache库

1. 基本使用
  官方git地址<https://github.com/janl/mustache.js>

- 循环对象数组
![](/images/image1.png)
- 循环数组
![](/images/image2.png)
- 二维数组
![](/images/image3.png)
- 数据对象
![](/images/image4.png)
- 是否渲染
![](/images/image5.png)

2. 底层核心机理

- 简单情况，使用正则表达式去实现

  >![](/images/string_replace.png)

  ```js
  const obj={
    name:'张三',
    age:18,
    hobby:'打篮球'
  }
  const template='姓名：{{name}}年龄：{{age}}兴趣：{{hobby}}'
  const render=(template,data)=>{
    return template.replace(/\{\{(\w+)\}\}/g, (find,$)=>data[$])
  }
  console.log(render(template,obj))
  ```

  ![](/images/replace.png)

- 复杂情况，无法使用正则表达式去实现
  ![mustache机理](/images/tokens.png)
  - mustache 库底层重点做的两件事：

    - 将模板字符串编译成 tokens 形式
    - 将 tokens 结合数据，解析为 dom 字符串

  - tokens 是什么？

    - 一个 JS 的嵌套数组，即 模板字符串的 JS 表示
    - 它是 “抽象语法树”、“虚拟节点” 等的开山鼻祖

3. 手写实现

`webpack`和`webpack-dev-server`构建
>模块化打包工具有 webpack (webpack-dev-server)、rollup、Parcel 等
Mustache 官方使用 rollup 进行模块化打包，我们使用 webpack (webpack-dev-server) 进行模块化打包

- webpack 开发体验很好，有热更新功能，可以在浏览器中实时调试程序
- 相比 nodejs，浏览器的控制台更好用（可以点击展开数组等）
- 生成库是 UMD 的，这意味着它可以同时在 nodejs 环境中使用，也可以在浏览器环境中使用。

> 构建项目，一路回车
>npm init
>注意版本可能会有兼容问题，最好使用以下版本
>npm install -D webpack@4
>npm install -D webpack-dev-server@3
>npm i -D webpack-cli@3

1. 在项目根目录下创建`webpack.config.js`文件，编写下面代码

```js
const path = require('path');
module.exports = {
    // 模式，开发
    mode: 'development',
    // 入口
    entry: './src/index.js',
    // 打包到什么文件
    output: {
        filename: 'bundle.js'
    },
    // 配置一下webpack-dev-server
    devServer: {
        // 静态文件根目录
        contentBase: path.join(__dirname, "www"),
        // 不压缩
        compress: false,
        // 端口号
        port: 8080,
        // 虚拟打包的路径，bundle.js文件没有真正的生成
        publicPath: "/xuni/"
    }
};

```

2. 创建`src/index.js`文件，编写下面代码

```js
console.log(123)
```

3. 创建 `www`文件夹，里面创建`index.html`文件，编写下面代码

```html
<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>模版引擎</title>
</head>

<body>
  <h1>hello world</h1>
</body>
<script src="/xuni/bundle.js"></script>
<script>
  const template = '<div>你好，{{name}}</div>';
  const data = { name: '张三' }
  Mustache.render(template, data)
</script>

</html>
```

4. 在`package.json`中添加`scripts`

```json
"scripts": {
  "dev":"webpack-dev-server"
}
```

5. 启动项目

```shell
npm run dev
```

- Scanner
创建`src/Scanner.js`文件，并在`src/index.js`文件中引入

```js
// main.js
import Scanner from './Scanner';
```

- 在`Scanner.js`文件中编写如下代码

  ```js
  export default class Scanner {
    constructor(template) {
      this.template = template;// template
      this.pos = 0;// position
      this.tail = template;// 模板字符串
    }
    scan(tag) {
      if (this.tail.indexOf(tag) === 0) {
        this.pos += tag.length;
        this.tail = this.tail.substring(this.pos);
      }
    }
    scanUntil(stopTag) {
      // 记录开始扫描的位置
      const start = this.pos;
      // 当模板字符串没有扫描，就一直循环
      while (!this.eos() && this.tail.indexOf(stopTag) != 0) {
        this.pos++;
        this.tail = this.template.substring(this.pos);
      }
      // 返回扫描的结果
      return this.template.substring(start, this.pos);
    }
    eos() {
      return this.pos >=this.template.length;
    }
  }

  ```

  - 测试
  在`src/index.js`文件中编写如下代码

  ```js
   render(template,data) {
      let word = null
      const scanner = new Scanner(template)
      while (scanner.pos!==template.length) {
        word = scanner.scanUntil('{{')
        scanner.scan('{{')
        console.log(word)
        word = scanner.scanUntil('}}')
        scanner.scan('}}')
        console.log(word)
      }
    }
  ```

- 将模版转Token `parseTemplateToToken`

  - 创建`src/parseTemplateToToken.js`文件，代码如下：

  ```js
  import Scanner from "./Scanner.js";
  export default function parseTemplateToToken (template) {
    let word = null // 记录
    let tokens=[]
    const scanner = new Scanner(template)
    while (scanner.pos!==template.length) {
      word = scanner.scanUntil('{{')
      if (word !== "") {
        tokens.push(['text', word])
      }
      scanner.scan('{{')
      word = scanner.scanUntil('}}')
      if (word !== '') {
        // 判断第一个字符是什么，如果是#
        if (word.charAt(0) === '#') {
          tokens.push(['#', word.substring(1)])
        } else if (word.charAt(0)==='/') {
          tokens.push(['/', word])
        } else {
          tokens.push(['name', word])
        }
      }
      scanner.scan('}}')
    }
    return tokens
  }
  ```

  - 创建`src/nestToken.js`文件，代码如下：

  ```js
  //折叠tokens 主要是处理循环遍历数据的token
  export default function nestTokens(tokens) {
      let nestedTokens = []
      let sections = []
      let collector = nestedTokens
      for (let i = 0; i < tokens.length; i++) {
          let token = tokens[i]
          switch (token[0]) {
              case "#":
                  collector.push(token)
                  sections.push(token)
                  collector = token[2] = []
                  break;
              case "/":
                  sections.pop()
                  collector = sections.length > 0 ? sections[sections.length - 1][2] : nestedTokens
                  break
              default:
                  collector.push(token)
                  break;
          }
      }
      return nestedTokens
  }

  ```

  - 在`src/parseTemplateToToken.js`文件中引入`nestToken.js`文件，增加如下代码：

  ```js
  import nestTokens from './nestTokens.js';
  export default function parseTemplateToToken (template) {
    // ....
    return nestTokens(tokens)
  }
  ```

- 创建`src/lookUp.js`文件，代码如下：

```js
export default function lookup(data, keyName) {
    let targetArray = keyName.split(".")
    let res = data
    for (let item of targetArray) {
        res = res[item]
    }
    return res
}
```

- 创建`src/render.js`文件，代码如下：

```js
import lookup from "./lookUp.js"
export default function renderTemplate(tokens, data) {
    let resultStr = ""
    for (let i = 0; i < tokens.length; i++) {
        let token = tokens[i]
        if (token[0] === "text") {
            resultStr = resultStr + token[1]
        } else if (token[0] === "name") {
            if (token[1] === ".") {
                resultStr = resultStr + data
            } else {
                resultStr = resultStr + lookup(data,token[1])
            }
        } else if (token[0] === "#") {
            let target = data[token[1]]
            for (let j = 0; j < target.length; j++) {
                resultStr = resultStr + renderTemplate(token[2], target[j])
            }
        }
    }
    return resultStr
}
```

- 修改`src/index.js`文件，代码如下：

```js
import parseTemplateToToken from './parseTemplateToToken';
import renderTemplate from './render';
window.Mustache = {
  render(template, data) {
    let tokens = parseTemplateToToken(template)
    let domStr = renderTemplate(tokens, data)
    return domStr
  }
}
```

> 这样一个简单的模板引擎就完成了，下面我们来测试一下。

- 在`www/index.html`中加入以下代码：

```html
<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>模版引擎</title>
</head>

<body>
  <div class="container"></div>
</body>
<script src="/xuni/bundle.js"></script>
<script>
  const template = `
          <div>数据的名字是:{{name}},年龄是:{{age}},今日心情:{{life.mood}}</div>
            <ul>
                {{#arr}}
                <li class="index">{{index}}</li>
                    {{#list}}
                        <div>{{.}}</div>
                    {{/list}}
                {{/arr}}
            </ul>
          `
  const data = {
    name: "小黄",
    age: "11",
    life: { mood: "happy" },
    arr: [
      { index: "1", list: ["吃饭1", "睡觉1"] },
      { index: "2", list: ["吃饭2", "睡觉2"] },
      { index: "3", list: ["吃饭3", "睡觉3"] },
    ]
  }
  const dom=Mustache.render(template, data)
  document.querySelector('.container').innerHTML=dom
</script>

</html><!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>模版引擎</title>
</head>

<body>
  <div class="container"></div>
</body>
<script src="/xuni/bundle.js"></script>
<script>
  const template = `
          <div>数据的名字是:{{name}},年龄是:{{age}},今日心情:{{life.mood}}</div>
            <ul>
                {{#arr}}
                <li class="index">{{index}}</li>
                    {{#list}}
                        <div>{{.}}</div>
                    {{/list}}
                {{/arr}}
            </ul>
          `
  const data = {
    name: "小黄",
    age: "11",
    life: { mood: "happy" },
    arr: [
      { index: "1", list: ["吃饭1", "睡觉1"] },
      { index: "2", list: ["吃饭2", "睡觉2"] },
      { index: "3", list: ["吃饭3", "睡觉3"] },
    ]
  }
  //
  const dom=Mustache.render(template, data)
  document.querySelector('.container').innerHTML=dom
</script>

</html>
```

- 使用`npm run dev`启动项目
- 访问`http://localhost:8080/`
- 在页面上可以看到
![](/images/mustache.png)

## 模版编译

## 虚拟DOM和diff算法

1. 虚拟DOM就是用js对象来描述真实DOM

```js
<div class="container">
  哈哈
  <h1 class="title">标题</h1>
</div>
// js对象
const dom={
  tag:'div',//标签
  attrs:{// 属性
    class:'container'
  },
  text:'哈哈',//文本
  children:[{
    tag:'h1',
    attrs:{class:'title'},
    text:'标题'
  }]//子节点
}
```

2. 为什么要有虚拟DOM
`Vue`是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作`DOM`,而操作真实`DOM`又是非常耗费性能的

```js
const div=document.createElement('div');
let str='';
for(const key in div){
  str+=key.toString()+'=';
}
console.log(str);
```

![](/images/dom.png)

这时候可以看到结果，一个简单的`div`标签就有很多个属性，如果页面中有很多标签，那么性能消耗是非常大的，
所以`Vue`中引入了虚拟DOM，将真实`DOM`转换成虚拟`DOM`，在更新视图的时候，
虚拟`DOM`会进行比较，比较出差异，然后只更新有差异的部分，这样就大大提高了性能

3. 虚拟DOM的实现

- 安装`snabbdom`

```bash
npm i snabbdom -D
```

- 创建`www/index.html`文件，添加以下代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>虚拟DOM</title>
</head>
<body>
  <div id="app"></div>
</body>
<script src="/xuni/bundle.js" type="module"></script>
</html>
```

- 创建`src/index.js`文件,添加以下代码：

```js
import {
    init,
    classModule,
    propsModule,
    styleModule,
    eventListenersModule,
    h,
} from "snabbdom";

//创建patch函数
const patch = init([classModule, propsModule, styleModule, eventListenersModule])

//创建虚拟节点
var myVnode = h('a', { props: { href: 'http://www.baidu.com' } }, "百度")
console.log(myVnode);

//让虚拟dom上树
const app = document.getElementById('app')
patch(app,myVnode)
```

- 启动项目

```bash
npm run dev
```

可以看到
![](/images/snabbdom.png)

4. 手写虚拟DOM

- `h`函数的实现：创建`src/h.js`文件，添加以下代码：

```js
import vnode from "./vnode";
export default function (sel, data, c) {
    if (arguments.length != 3) {
        throw new Error("参数错误")
    }
    if (typeof c == 'string' || typeof c == 'number') {
        return vnode(sel, data, undefined, c, undefined)
    } else if (Array.isArray(c)) {
        let children=[]
        for (let i = 0; i < c.length; i++) {
            if (!(typeof c[i] == 'object' && c[i].hasOwnProperty('sel'))) {
                throw new Error("数组子项错误")
            }
            children.push(c[i])
        }
        return vnode(sel,data,children,undefined,undefined)
    } else if (typeof c == 'object' && c.hasOwnProperty('sel')) {
        let children=[]
        children.push(c)
        return vnode(sel,data,children,undefined,undefined)
    } else {
        throw new Error("第三个参数类型错误")
    }
}
```

- `vnode`的实现：创建`src/vnode.js`文件，添加以下代码：

```js
// 很简单就是返回组合对象
export default function (sel, data, children, text, elm) {
    return { sel, data, children, text, elm }
}
```

- `diff算法`：
  - key 很重要，key 是节点的唯一标识，它会告诉 diff 算法，在更改前后它们是同一个 DOM 节点
  - 只有是同一个虚拟节点，才会进行精细化比较，否则就是暴力删除旧的，插入新的
  - 只进行同层比较，不会进行跨层比较，否则还是暴力删除旧的，插入新的
- `patch`函数的实现：创建`src/patch.js`文件，添加以下代码：
![patch](/images/patch.png)

```js
import vnode from "./vnode";
import createElement from './createElement'
import patchVnode from "./patchVnode";
export default function (oldNode, newNode) {
    //判断第一个节点是否为虚拟节点
    if (oldNode.sel == '' || oldNode.sel == undefined) {
        oldNode = vnode(oldNode.tagName.toLowerCase(), {}, [], undefined, oldNode)
        oldNode.key = "realDom"
    }
    //同一个节点精细比较
    if (sameNode()) {
        console.log("相同节点");
        patchVnode(oldNode,newNode)
    } else {
        // 不是同一个节点，暴力插入新的，删除旧的
        console.log("暴力插入");
        let newRealDom = createElement(newNode)
        if (oldNode.elm.parentNode && newRealDom) {
            oldNode.elm.parentNode.insertBefore(newRealDom, oldNode.elm)
            oldNode.elm.remove()
        }
    }
    //判断是不是同一个节点
    function sameNode() {
        return (oldNode.key == newNode.key && oldNode.sel == newNode.sel)
    }
}
```

- `createElement`函数的实现：创建`src/createElement.js`文件，添加以下代码：

```js
//创建真正的节点，将vnode创建为dom
function createElement(vnode) {
    let domNode = document.createElement(vnode.sel)
    if (vnode.text != '' && vnode.children == undefined) {
        domNode.innerText = vnode.text
    } else if (Array.isArray(vnode.children) && vnode.children.length != 0) {
        for (let item of vnode.children) {
            let chNode = createElement(item)
            domNode.appendChild(chNode)
        }
    }
    vnode.elm = domNode
    return vnode.elm
}
export default createElement
```

![比较](/images/image.png)

- `patchVnode`函数的实现：创建`src/patchChildren.js`文件，添加以下代码：

```js
import updateChildren from "./updateChildren"
export default function (oldNode, newNode) {
    if (oldNode == newNode) {
        return console.log("同一节点不处理")
    }
    //新节点有text
    if (newNode.text != undefined) {
        //新老text不同 老的就算是有子节点也会被替换掉
        if (oldNode.text != newNode.text) {
            oldNode.elm.innerText = newNode.text
        }
        //新节点无text 有children
    } else {
        //新老都有children
        if (oldNode.children != undefined && oldNode.children.length > 0) {
            //运用四种命中策略
            //新前旧前
            //新后旧后
            //新后旧前
            //新前旧后
            updateChildren(oldNode.elm, oldNode.children, newNode.children)
        }
    }
}
```

diff 中四种命中查找：

- 新前与旧前，命中则，同时下移
- 新后与旧后，命中则，同时上移
- 新后与旧前，命中则，新前指向的节点，移动到旧后之后
- 新前与旧后，命中则，新前指向的节点，移动到旧前之前
- 命中一种就不再进行判断，未命中则从上往下依次判断

如果都没有命中，就需要用循环来进行寻找
![](/images/image-1.png)

- 创建`src/updateChildren.js`文件，添加以下代码：

```js
//处理新旧节点都有children的情况
import patchVnode from "./patchVnode"
import createElement from "./createElement"
function sameNode(a, b) {
    return (a.key === b.key && a.sel === b.sel)
}
export default function (pElm, oldCh, newCh) {
    //四个指针
    let oldStartIdx = 0
    let newStartIdx = 0
    let oldEndIdx = oldCh.length - 1
    let newEndIdx = newCh.length - 1
    //四个节点
    let oldStartVnode = oldCh[0]
    let newStartVnode = newCh[0]
    let oldEndVnode = oldCh[oldEndIdx]
    let newEndVnode = newCh[newEndIdx]
    let keymap = null  //key缓存
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        console.log("★")
        //略过undefined
        if (oldStartVnode == null || oldCh[oldStartIdx] == undefined) {
            oldStartVnode = oldCh[++oldStartIdx]
        } else if (oldEndVnode == null || oldCh[oldEndIdx] == undefined) {
            oldEndVnode = oldCh[--oldEndIdx]
        } else if (newStartVnode == null || newCh[newStartIdx] == undefined) {
            newStartVnode = newCh[++newStartIdx]
        } else if (newEndVnode == null || newCh[newEndIdx] == undefined) {
            newEndVnode = newCh[--newEndIdx]
        } else if (sameNode(oldStartVnode, newStartVnode)) {
            //命中新前旧前
            patchVnode(oldStartVnode, newStartVnode)
            oldStartVnode = oldCh[++oldStartIdx]
            newStartVnode = newCh[++newStartIdx]
        } else if (sameNode(newEndVnode, oldEndVnode)) {
            //新后与旧后
            patchVnode(oldEndVnode, newEndVnode)
            oldEndVnode = oldCh[--oldEndIdx]
            newEndVnode = newCh[--newEndIdx]
        } else if (sameNode(newEndVnode, oldStartVnode)) {
            //新后与旧前
            patchVnode(oldStartVnode, newEndVnode)
            //移动新前指向的节点到老节点的旧后后面
            pElm.insertBefore(oldStartVnode.elm, oldEndVnode.elm.nextSibling)
            oldStartVnode = oldCh[++oldStartIdx]
            newEndVnode = newCh[--newEndIdx]
        } else if (sameNode(newStartVnode, oldEndVnode)) {
            //新前与旧后
            patchVnode(oldEndVnode, newStartVnode)
            //移动新前指向的节点到老节点的旧前前面
            pElm.insertBefore(oldEndVnode.elm, oldStartVnode.elm)
            oldEndVnode = oldCh[--oldEndIdx]
            newStartVnode = newStartVnode[++newStartIdx]
        } else {
            //四种方式都没命中
            // 寻找keymap
            if (!keymap) {
                keymap = {}
                //将key与索引存为键值对
                for (let i = oldStartIdx; i <= oldEndIdx; i++) {
                    const key = oldCh[i].key
                    if (key != undefined) {
                        keymap[key] = i
                    }
                }
            }
            console.log(keymap)
            //获取新节点是否在旧节点map中出现
            const idxInOld = keymap[newStartVnode.key]
            if (idxInOld == undefined) {
                //说明是全新的项
                pElm.insertBefore(createElement(newStartVnode), oldStartVnode.elm)
            } else {
                //移动
                const eleToMove = oldCh[idxInOld]
                if (eleToMove) {
                    patchVnode(eleToMove, newStartVnode)
                    //把这项设置为undefined
                    oldCh[idxInOld] = undefined;
                    // 移动
                    pElm.insertBefore(eleToMove.elm, oldStartVnode.elm)
                }
            }
            newStartVnode = newCh[++newStartIdx]
        }
    }
    //循环结束继续处理
    if (newStartIdx <= newEndIdx) {
        //还有新的
        for (let i = newStartIdx; i <= newEndIdx; i++) {
            //insertBefrore参考节点为null时自动添加到末尾
            pElm.insertBefore(createElement(newCh[i]), oldCh[oldStartIdx].elm)
        }
    } else if (oldStartIdx <= oldEndIdx) {
        // old还有旧的
        for (let i = oldStartIdx; i <= oldEndIdx; i++) {
            if (oldCh[i])
                pElm.removeChild(oldCh[i].elm)
        }
    }
}
```

完成了虚拟DOM的核心逻辑

## 响应式原理

### 数据响应式

![](/images/image-2.png)

侵入式和非侵入式
![](/images/image-3.png)

### `Object.defineProperty`

`Object.defineProperty()` 用于数据劫持 / 数据代理，利用 JavaScript 引擎赋予的功能，检测对象属性变化。

该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。

```js
var obj = {}

Object.defineProperty(obj, 'a', {
    value: 3, // 值
    writable: false, // 只读
    enumerable: true, // 可枚举
})

console.log(obj.a) // 3
obj.a++ // 只读的，不能修改
console.log(obj.a); // 3
```

该方法的`getter/setter`需要变量周转才能工作

```js
var obj = {}
var temp // 临时变量

Object.defineProperty(obj, 'a', {
    get() {
        console.log('get a');
        return temp
    },
    set(newVal) {
        console.log('set a',  newVal);
        temp = newVal
    }
})

obj.a = 1
obj.a++
console.log(obj.a) // 2

```

自定义一个 `defineReactive` 函数，使用闭包，就不需要设置临时变量：

```js
export default function defineReactive(obj, key, val) {
    if (arguments.length == 2) {
        val = obj[key]
    }
    Object.defineProperty(obj, key, {
        enumerable: true, // 可枚举
        configurable: true, // 可配置
        get() {
            console.log('get', key);
            return val
        },
        set(newVal) {
            console.log('set', key, newVal);
            if (val === newVal) return
            val = newVal
        }
    })
}
```

```js
let obj = {}

// 实现了数据响应式
defineReactive(obj, 'a', 1)
console.log(obj.a); // 1
obj.a = 10
console.log(obj.a); // 10
```

### 递归检测对象全部属性

对于如下对象，使用上面的 `defineReactive` 是无法监听 `obj.a.m.n` 的属性的（只能监听一层，无法监听多层）

```js
let obj = {
    a: {
        m: {
            n: 1
        }
    },
    b: 1
}

```

想要达到的效果：通过 `observe` 使 obj 所有属性都变成响应式的

```js
observe(obj)
obj.b++ // 响应式
obj.a.m.n++ // 响应式

```

程序流程图：（通过各级函数之间的调用实现了递归的效果）

![](/images/image-4.png)

`observe.js`

```js
/**
 * 将 obj 所有属性变为响应式
 */
export default function observe(obj) {
    if (!obj || typeof obj !== 'object') return
    var ob;
 // 判断是否已经是响应式
    if (typeof obj.__ob__ != 'undefined') {
        ob = obj.__ob__
    } else {
        ob = new Observer(obj)
    }
    return ob
}
```

`Observer.js`:

```js
/**
 * 将一个正常的 object 转换成每个层级的属性都是响应式的 object
 */
export default class Observer {
    constructor(obj) {
        console.log('Observer constructor', obj);
        // 构造函数中的 this 不是类本身，而是表示实例
        def(obj, '__ob__', this, false)
        // 将 object 中的属性转换成响应式的属性
        this.walk(obj)
    }
    // 遍历 object 的属性，将其转换成响应式的属性
    walk(obj) {
        console.log('walk', obj);
        for (let k in obj) {
            defineReactive(obj, k)
        }
    }
}

/**
 * 对 Object.defineProperty 的封装
 */
export const def = function (obj, key, value, enumerable) {
    Object.defineProperty(obj, key, {
        value,
        enumerable,
        writable: true,
        configurable: true
    })
}
```

`defineReactive.js`

```js
/**
 * 将数据变为响应式
 */
export default function defineReactive(obj, key, val) {
    console.log('defineReactive', key);
    if (arguments.length == 2) {
        val = obj[key]
    }

    // 子元素要进行 observe，至此形成递归
    // 这个递归是多个函数、类循环调用
    let childOb = observe(val)

    Object.defineProperty(obj, key, {
        enumerable: true, // 可枚举
        configurable: true, // 可配置
        get() {
            // console.log('get', key);
            return val
        },
        set(newVal) {
            console.log('set', key, newVal);
            if (val === newVal) return
            val = newVal
            // 当设置了新值，这个新值也要被 observe
            childOb = observe(newVal)
        }
    })
}
```

测试：

```js
let obj = {
    a: {
        m: {
            n: 1
        }
    },
    b: 1
}

observe(obj)
obj.b++ // 响应式
obj.a.m.n++ // 响应式
```

![](/images/image-5.png)

### 数组的响应式原理

对于数组对象，以上实现是无法监听其 push、pop 等元素修改方法的：

```js
let obj = {
 c: [1, 2, 3, 4]
}
```

改写 7 个方法：`push`、`pop`、`shift`、`unshift`、`splice`、`sort`、`reverse`
![](/images/image-6.png)
`Array.js`

```js
// 数组的原型
const arrayPrototype = Array.prototype

// 以 Array.prototype 为原型创建 arrayMethods 对象，并暴露
export const arrayMethods = Object.create(arrayPrototype)

// 要被改写的 7 个数组方法
const methodsNeedChange = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
]

// 数组方法实际是自己写的，自己写的再调用真实的数组方法，中间可以拦截数据
methodsNeedChange.forEach(methodName => {
    // 备份原来的方法
    const originMethod = arrayPrototype[methodName]
    // 给原型定义新的方法
    def(arrayMethods, methodName, function () {
        console.log('arrayMethods', methodName);

        // 执行原来的函数
        const result = originMethod.apply(this, arguments)
        // arguments 是伪数组对象，转成数组对象
        const args = [...arguments]

        // 把数组身上的 __ob__ 取出来
        const ob = this.__ob__

        // 有三种方法 push / unshift / splice 可以插入新项
        // 要将插入的新项也变为 observe 的
        let inserted = []

        switch (methodName) {
            case 'push':
            case 'unshift':
                inserted = args
                break;
            case 'splice':
                // splice(下标, 数量, 插入的新项)
                inserted = args.slice(2)
                break;
        }

        // 判断有没有要插入的新项，让新项也变为响应的
        if (inserted) ob.observeArray(inserted)

        return result
    }, false)
})
```

修改 `Observer.js` 中构造 Observer 的代码：

```js
/**
 * 将一个正常的 object 转换成每个层级的属性都是响应式的 object
 */
export default class Observer {
    constructor(obj) {
        console.log('Observer constructor', obj);
        // 构造函数中的 this 不是类本身，而是表示实例
        def(obj, '__ob__', this, false)
        // 将 object 中的属性转换成响应式的属性
        if (Array.isArray(obj)) {
            // 将数组的原型指向 arrayMethods
            Object.setPrototypeOf(obj, arrayMethods)
            // 让数组变的 observe
            this.observeArray(obj)
        } else {
            this.walk(obj)
        }
    }
    // 遍历 object 的属性，将其转换成响应式的属性
    walk(obj) {
        console.log('walk');
        for (let k in obj) {
            defineReactive(obj, k)
        }
    }
    // 数组的特殊遍历
    observeArray(arr) {
        for (let i = 0, l = arr.length; i < l; i++) {
            // 逐项进行 observe
            observe(arr[i])
        }
    }
}
```

### 依赖收集

需要用到数据的地方，称为依赖
Dep 类 和 Watcher 类：

- Dep 类封装了依赖收集的代码，专用用来管理依赖，每个 Observer 的实例，成员中都有一个 Dep 的实例
- Watcher 是一个中介，数据发生变化时通过 Watcher 中转，通知组件
![](/images/image-7.png)
- 依赖就是 Watcher，只有 Watcher 触发的 getter 才会收集依赖，哪个 Watcher 触发了 getter，就会把哪个 Watcher 收集到 Dep
- Dep 使用发布订阅模式，当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍
- 代码实现的巧妙之处：Watcher 把自己设置到全局的一个指定位置，然后读取数据，因为读取到了数据，所以会触发这个数据的 getter。在 getter 中就能得到当前正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中。
![](/images/image-8.png)
[参考文章](https://blog.csdn.net/Mikon_0703/article/details/111367773)

测试

```js
let obj = {
    a: 1,
    b: {
        m: {
            n: 1
        }
    },
    c: [1, 2, 3, 4]
}

observe(obj)

// 监控依赖
new Watcher(obj, 'b.m.n', val => {
    console.log('Watcher 在监控 b.m.n', val)
})

obj.b.m.n++
console.log(obj)

```

`Dep.js`

```js
/**
 * 全局唯一的 依赖收集器
 */
export default class Dep {
    constructor() {
        // console.log('Dep constructor');
        this.id = uid++

        // 用数组存储自己的订阅者，这个数组中存放 Watcher 实例
        this.subs = [] // subscribers
    }
    // 添加订阅
    addSub(sub) {
        this.subs.push(sub)
    }
    // 添加依赖
    depend() {
        // Dep.target 就是自己指定的全局的位置（window.targte 也可以，全局唯一即可）
        if (Dep.target) {
            this.addSub(Dep.target)
        }
    }
    // 通知更新
    notify() {
        console.log('Dep notify');
        // 浅克隆一份
        const subs = this.subs.slice()
        for (let i = 0, l = subs.length; i < l; i++) {
            subs[i].update()
        }
    }
}

```

`Watcher.js`

```js
var uid = 0

export default class Watcher {
    // 监听 target 对象的 expression 属性，执行 callback 回调
    constructor(target, expression, callback) {
        // console.log('Watcher constructor');
        this.id = uid++
        this.target = target
        this.getter = parsePath(expression) // 解析 expression 为一个函数
        this.callback = callback
        this.value = this.get()
    }
    update() {
        // console.log('Watcher update');
        this.run()
    }
    get() {
        // 进入依赖收集阶段，让全局 Dep.tartget 设置为 Watcher 本身
        Dep.target = this

        const obj = this.target
        // 只要没找到，就一直找
        let value
        try {
            value = this.getter(obj)
        } finally {
            Dep.target = null
        }

        return value
    }
    run() {
        this.getAndInvoke(this.callback)
    }
    getAndInvoke(cb) {
        const value = this.get()

        if (value !== this.value || typeof value == 'object') {
            const oldValue = this.value
            this.value = value
            cb.call(this.target, value, oldValue)
        }
    }
}

// 返回一个可以解析 "a.b.c" 格式的函数
// let fn = parsePath('a.b.c')
// fn({ a: { b: { c: 1 } } })
function parsePath(str) {
    var segments = str.split('.');
    return obj => {
        for (let i = 0; i < segments.length; i++) {
            if (!obj) return
            obj = obj[segments[i]];
        }
        return obj
    }
}
```

## AST抽象语法树

### 什么是抽象语法书

- 从 模板语法 直接编译到 HTML 语法 十分困难
- 通过 抽象语法树 进行过度会让这个工作变得简单
![](/images/image-9.png)
![](/images/image-10.png)
抽象语法树本质上就是一个 JS 对象：
- 理解为 HTML 语法通过一系列规则对应到的 JS 对象
![](/images/image-11.png)
- 抽象语法树 和 虚拟节点 的关系：
![](/images/image-12.png)

### 指针

题目：试寻找字符串中，连续重复次数最多的字符。

```js
function findMaxChar(str) {
    let i = 0, j = 1
    let maxChar = str[i], maxRepeat = -1

    while (i < str.length) {
        if (str[i] != str[j]) {
            if (j - i > maxRepeat) {
                maxRepeat = j - i
                maxChar = str[i]
            }
            i = j
        }
        j++
    }
    console.log(`最多的字母是 ${maxChar}，重复了 ${maxRepeat} 次`);
}

let str = 'aaaabbbbbcccccccccccccdddddd'
findMaxChar(str)

```

### 递归

题目1：试输出斐波那契数列的前10项，即1、1、2、3、5、8、13、21、34、55。然后请思考，代码是否有大量重复的计算？应该如何解决重复计算的问题

无缓存的递归：

```js
function fib(n) {
    return n <= 1 ? n : fib(n - 1) + fib(n - 2)
}

```

有缓存的递归：

```js
let cache = {}
function fib(n) {
    if (n in cache) return cache[n]
    return cache[n] = (n <= 1 ? n : fib(n - 1) + fib(n - 2))
}

```

>可以在函数中添加 `console.count()` 来对该函数的调用次数进行计数

题目2：试将高维数组 `[1, 2, [3, [4, 5], 6], 7, [8], 9]` 变为下方所示的对象

```js
{
  children: [
    { value: 1 },
    { value: 2 },
    {
      children: [
        { value: 3 },
        { children: [{ value: 4 }, { value: 5 }] },
        { value: 6 }
      ]
    },
    { value: 7 },
    { children: [{value: 8}] },
    { value: 9 }
  ]
};

```

```js
// 转换函数1
function convert(arr) {
    return {children: help(arr)}
}

function help(arr) {
  let res = [];
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] === "number") {
      res.push({ value: arr[i] });
    } else if (Array.isArray(arr[i])) {
      res.push({ children: help(arr[i]) });
    }
  }
  return res;
}

```

```js
// 转换函数2
function convert(item) {
  if (typeof item == 'number')
    return { value: item }
  if (Array.isArray(item))
    return { children: item.map(_item => convert(_item)) }
}
```

### 栈
>
>JavaScript 中，栈可以用数组模拟，使用 push() 和 pop()
>
题目：试编写 “智能重复” smartRepeat 函数，实现：

- 将 `3[abc]` 变为 `abcabcabc`
- 将 `3[2[a]2[b]]` 变为 `aabbaabbaabb`
- 将 `2[1[a]3[b]2[3[c]4[d]]]` 变为 `abbbcccddddcccddddabbbcccddddcccdddd`
不用考虑输入字符串是非法的情况，比如：

`2[a3[b]]` 是错误的，应该补一个 1，即 `2[1[a]3[b]]`
`[abc]` 是错误的，应该补一个 1，即 `1[abc]`
>一般遇到括号相关，需要做词法分析的时候，经常会使用到栈

思路：遍历每一个字符

如果这个字符是 数字，将数字压入栈A，空字符压入 栈B
如果这个字符是 字母，将 栈B 的栈顶改为该字母
如果这个字符是 ]，将 栈A 和 栈B 分别弹栈，进行组合，将组合结果拼接到 栈B 最顶层的字符串后面

```js
function smartRepeact(templateStr) {
    let stackA = [] // 存放数字
    let stackB = [] // 存放临时字符串
    let rest = templateStr // 剩余字符串

    let idx = 0 // 指针
    while (idx < templateStr.length - 1) {
        rest = templateStr.substring(idx) // 更新剩余字符串
        if (/^\d+\[/.test(rest)) { // 判断是否以数字和 [ 开头
            // 取出开头的数字
            let times = Number(rest.match(/^(\d+)\[/)[1])
            stackA.push(times)
            stackB.push('')
            idx += times.toString().length + 1
        } else if(/^\w+\]/.test(rest)) { // 判断是否以字母和 ] 开头
            // 如果这个字符是字母，那么就把B栈顶这项改为这个字母
            // 取出开头的字母
            let word = rest.match(/^(\w+)\]/)[1]
            stackB[stackB.length - 1] = word
            idx += word.length
        } else if (rest[0] === ']') {
            // 如果这个字符是 ]，组合两个栈的结果并放入栈B
            let times = stackA.pop() // 取出栈顶的数字
            let word = stackB.pop() // 取出栈顶的字符串
            stackB[stackB.length - 1] += word.repeat(times)
            idx++
        }
    }
    return stackB[0].repeat(stackA[0])
}

```

### 正则表达式

补充一点 JS 中常用的正则表达式的知识：

```js
// replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串
'abc666def123'.replace(/\d/g, '') // abcdef

// search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串
// 找不到则返回 -1
'abc666def123'.search(/\d/g)  // 3

// match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配
// 找不到则返回 null
'abc666def123'.match(/\d/g) // ['6', '6', '6', '1', '2', '3']

// test() 方法用于检测一个字符串是否匹配某个模式
/^\d/.test('5abc') // true
/^\d/.test('abc') // false
```

### 手写抽象语法树

1. 识别开始结束标签

`parse.js`

```js
export default function parse(templateStr) {
    let rest = ''

    // 开始标签的正则
    const startRegExp = /^\<([a-z]+[1-6]?)\>/
    // 结束标签的正则
    const endRegExp = /^\<\/([a-z]+[1-6]?)\>/
    // 结束标签前文字的正则（注意开头不含 <）
    const wordRegExp = /^([^\<]+)\<\/[a-z]+[1-6]?\>/

    let stackA = [], stackB = []

    let index = 0
    while (index < templateStr.length - 1) {
        rest = templateStr.substring(index)
        if (startRegExp.test(rest)) { // 识别遍历到的字符，是 开始标签
            let tag = rest.match(startRegExp)[1];
            // console.log(`检测到开始标记：<${tag}>`);
            stackA.push(tag) // 将开始标记推入 栈A
            stackB.push([]) // 将空数组推入 栈B
            // 移动开始标签的长度，由于 <> 是两个字符，所以需要 + 2
            index += tag.length + 2
        } else if (endRegExp.test(rest)) { // 识别遍历到的字符，是 结束标签
            let tag = rest.match(endRegExp)[1];
            // console.log(`检测到结束标记：</${tag}>`);
            // 此时，tag 一定和 栈A 顶部是相同的
            if (tag === stackA[stackA.length - 1]) {
                stackA.pop()
            } else {
                throw new Error(`${stackA[stackA.length - 1]} 标签没有封闭`)
            }
            // 移动结束标签的长度，由于 </.> 是两个字符，所以需要 + 3
            index += tag.length + 3
        } else if (wordRegExp.test(rest)) { // 识别到遍历的字符，是 文字（并且不能为全空）
            let word = rest.match(wordRegExp)[1];
            if (!/^\s+$/.test(word)) {
                console.log(`检测到文字：${word}`);
            }
            // 指针移动到文字的末尾
            index += word.length
        } else {
            index++
        }

        // 未考虑文字在标签后面的情况，如：
        // <p>123</p> hello
    }
}

```

2. 使用栈形成 AST

```js
let htmlStr = `<div>
    <h1>Hello</h1>
    <ul>
        <li>111</li>
        <li>222</li>
        <li>333</li>
    </ul>
</div>`;

const ast = parse(htmlStr)
console.log(ast);

```

![](/images/image-13.png)
`parse.js`

```js
export default function parse(templateStr) {
  let rest = "";

  // 开始标签的正则
  const startRegExp = /^\<([a-z]+[1-6]?)\>/;
  // 结束标签的正则
  const endRegExp = /^\<\/([a-z]+[1-6]?)\>/;
  // 结束标签前文字的正则（注意开头不含 <）
  const wordRegExp = /^([^\<]+)\<\/[a-z]+[1-6]?\>/;

  let stackA = [];
  let stackB = [{ children: [] }];

  let index = 0;
  while (index < templateStr.length - 1) {
    rest = templateStr.substring(index);
    if (startRegExp.test(rest)) { // 识别遍历到的字符，是 开始标签
      let tag = rest.match(startRegExp)[1];
      console.log(`检测到开始标记：<${tag}>`);
      stackA.push(tag); // 将开始标记推入 栈A
      stackB.push({ tag: tag, children: [] }); // 将空数组推入 栈B
      // 移动开始标签的长度，由于 <> 是两个字符，所以需要 + 2
      index += tag.length + 2;

      // console.log(stackA, stackB);
    } else if (endRegExp.test(rest)) { // 识别遍历到的字符，是 结束标签
      let tag = rest.match(endRegExp)[1];
      console.log(`检测到结束标记：</${tag}>`);
      let pop_tag = stackA.pop();
      // 此时，tag 一定和 栈A 顶部是相同的
      if (tag === pop_tag) {
        let pop_arr = stackB.pop();
        if (stackB.length > 0) {
          stackB[stackB.length - 1].children.push(pop_arr);
        }
      } else {
        throw new Error(`${stackA[stackA.length - 1]} 标签没有封闭`);
      }
      // 移动结束标签的长度，由于 </.> 是两个字符，所以需要 + 3
      index += tag.length + 3;

      // console.log(stackA, stackB);
    } else if (wordRegExp.test(rest)) { // 识别到遍历的字符不是 文字（并且不能为全空）
      let word = rest.match(wordRegExp)[1];
      // 文字不能全是空
      if (!/^\s+$/.test(word)) {
        console.log(`检测到文字：${word}`);
        // 改变此时 stackB 中的栈顶元素
        stackB[stackB.length - 1].children.push({ text: word, type: 3 });
        console.log(stackB);
      }
      // 指针移动到文字的末尾
      index += word.length;
    } else {
      index++;
    }

    // 未考虑文字在标签后面的情况，如：
    // <p>123</p> hello
  }
  console.log(stackB);
  return stackB[0].children[0]
}

```

3. 识别 Attrs
`parseAttrsString.js`：把 attrsString 解析成 attrs 对象数组

- 解析前的字符串：`class="box red" id="mybox"`
- 解析后的对象数组：

```js
[
 {
  name: 'class',
  value: 'box red'
 },
 {
  name: 'id',
  value: 'mybox'
 }
]
```

`parseAttrsString` 算法核心思路：

- 遍历 `attrsStr`，如果遇到了空格，且不在引号中，则将前一个断点到当前为止的字符串加入 `result`

```js
/**
 * 把 attrsString 解析成 attrs 对象数组
 */
export default function parseAttrsString(attrsStr) {
    if (!attrsStr) return []

    let inFlag = false // 当前是否处于引号内
    let point = 0 // 断点处

    let result = []
    // 遍历 attrsStr，不能直接用 split()，有如下情况 class="aa bb cc" id="gg"
    for (let i = 0; i < attrsStr.length; i++) {
        let c = attrsStr[i]
        if (c === '"') inFlag = !inFlag // 遇到 双引号，切换 inFlag 状态
        else if (c === ' ' && !inFlag) { // 遇见 空格，且不在引号中
            if (!/^\s*$/.test(attrsStr.substring(point, i))) {
                // 不全为空格
                result.push(attrsStr.substring(point, i).trim())
                point = i
            }
        }
    }
    // 循环结束后，还剩一个属性
    result.push(attrsStr.substring(point).trim())
    // 将 ["k1=v1", "k2=v2"] 变为 [{name: k1, value: v1}, {name: k2, value: v2}]
    result = result.map(item => {
        const o = item.match(/^(.+)="(.+)"$/)
        return { name: o[1], value: o[2] }
    })
    return result
}

```

`parse.js`：

```js
export default function parse(templateStr) {
  let rest = "";

  // 开始标签的正则
  const startRegExp = /^\<([a-z]+[1-6]?)(\s[^\<]+)?\>/;
  // 结束标签的正则
  const endRegExp = /^\<\/([a-z]+[1-6]?)\>/;
  // 结束标签前文字的正则（注意开头不含 <）
  const wordRegExp = /^([^\<]+)\<\/[a-z]+[1-6]?\>/;

  let stackA = [];
  let stackB = [{ children: [] }];

  let index = 0;
  while (index < templateStr.length - 1) {
    rest = templateStr.substring(index); // 更新剩余字符串
    if (startRegExp.test(rest)) { // 识别遍历到的字符，是 开始标签
      let tag = rest.match(startRegExp)[1]; // 标签内容
      let attrsString = rest.match(startRegExp)[2] // attr 内容
    //   console.log(`检测到开始标记：<${tag}>`);
      stackA.push(tag); // 将开始标记推入 栈A
      stackB.push({
        tag: tag,
        children: [],
        attrs: parseAttrsString(attrsString) // 解析属性字符串
      }); // 将空数组推入 栈B
      // 移动开始标签的长度，由于 <> 是两个字符，所以需要 + 2，还需加上 attrs 的长度
      index += tag.length + 2 + (attrsString?.length || 0);
      // console.log(stackA, stackB);
    } else if (endRegExp.test(rest)) { // 识别遍历到的字符，是 结束标签
      let tag = rest.match(endRegExp)[1]; // 标签内容
    //   console.log(`检测到结束标记：</${tag}>`);
      let pop_tag = stackA.pop(); // 栈A 顶部元素
      // 此时，tag 一定和 栈A 顶部是相同的
      if (tag === pop_tag) {
        let pop_arr = stackB.pop();
        if (stackB.length > 0) {
          stackB[stackB.length - 1].children.push(pop_arr);
        }
      } else {
        throw new Error(`${pop_tag} 标签没有封闭`);
      }
      // 移动结束标签的长度，由于 </> 是两个字符，所以需要 + 3
      index += tag.length + 3;
      // console.log(stackA, stackB);
    } else if (wordRegExp.test(rest)) { // 识别到遍历的字符，是 文字（并且不能为全空）
      let word = rest.match(wordRegExp)[1];
      // 文字不能全是空
      if (!/^\s+$/.test(word)) {
        // console.log(`检测到文字：${word}`);
        // 改变此时 stackB 中的栈顶元素
        stackB[stackB.length - 1].children.push({ text: word, type: 3 });
        // console.log(stackB);
      }
      // 指针移动到文字的末尾
      index += word.length;
    } else {
      index++;
    }

    // 未考虑文字在标签后面的情况，如：
    // <p>123</p> hello
  }
  return stackB[0].children[0]
}

```

## 指令和生命周期

- `documentFragment`
`document.createDocumentFragment()` 用来创建一个虚拟的节点对象（文档片段对象）

`fragment` 认为是一个 dom 节点的收容器，原本要向 dom 中插入多少个节点就需要浏览器回流多少次，fragment 之后把要插入的节点先放入这个收容器中，这样再一次性插入，可以使浏览器只回流一次。

使用这个来模拟 Vue 中的 AST 抽象语法树（简化版的 AST）

- DOM nodeType
nodeType 属性返回节点类型（只读）

  - 元素节点，nodeType 属性返回 1
  - 属性节点, nodeType 属性返回 2
  - 文本节点，nodeType 属性返回 3
  - 注释节点，nodeType 属性返回 8

- 类数组
类数组就是形式像数组一样，但是没有数组的方法（有 length 属性）的对象

```js
// 这是个类数组
let arrayLike = {
   0: "java",
   1: "C++",
   2: "javascript",
   length: 3
}

```

JavaScript 在以下情况中的对象是 类数组：

- 函数里面的参数对象 arguments
- 使用 `getElementsByName / TagName / ClassName` 获得到的 `HTMLCollection`
- 用 `querySelector` 获得的 `NodeList`

- `arguments`

```js
function sum(a, b, c) {
  console.log(arguments)
  console.log(typeof arguments) // object
  console.log(Object.prototype.toString.call(arguments)) // [object Arguments]
  console.log(arguments.callee)
}
sum(1, 2, 3)

```

![](/images/image-14.png)

- `HTMLCollection`

```html
<div class="son">
   张三
</div>
<div class="son">
   李四
</div>
<div class="son">
   王五
</div>

<script>
 var arrayList = document.getElementsByClassName("son")
 console.log(arrayList)
 console.log(Array.isArray(arrayList)) // false
 console.log(typeof arrayList) // object
 console.log(Object.prototype.toString.call(arrayList)) // [object HTMLCollection]
</script>

```

![](/images/image-15.png)

- `NodeList`

```html
<div class="son">
   张三
</div>
<div class="son">
   李四
</div>
<div class="son">
   王五
</div>

<script>
    var arrayList = document.querySelector(".son")
    console.log(Array.isArray(arrayList)) // fasle
    console.log(arrayList) // object
    console.log(typeof arrayList) // [object HTMLDivElement]
    console.log(Object.prototype.toString.call(arrayList))
</script>

```

![](/images/image-16.png)

### 手写一个简易版 Vue

使用效果

```html
<div id="app">
 {{a}}
 <button onclick="add()">增加数字</button>
 <input type="text" v-model="a">
</div>

<script src="/xuni/bundle.js"></script>

<script>
 let vm = new Vue({
  el: '#app',
  data: {
   a: 10,
  },
  watch: {
   a() {
    console.log('a 变化了');
   }
  }
 })
 console.log(vm);

 function add() {
  vm.a++
 }
</script>

```

`Vue` 这个类应当挂载在 `windows` 对象上：

```js
window.Vue = Vue
```

`Vue.js`：简易版的 `Vue` 类

```js
export default class Vue {
    constructor(options) {
        this.$options = options || {}
        this._data = options?.data || undefined
        // 将数据变成响应式
        observe(this._data)
        // 将数据添加到实例中
        this._initData()
        // 调用默认的 watch
        this._initWatch()
        // 模板编译
        new Compile(options.el, this)
    }

    /**
     * 将数据添加到实例中
     */
    _initData() {
        let self = this
        Object.keys(this._data).forEach(key => {
            Object.defineProperty(self, key, {
                get() {
                    return self._data[key]
                },
                set (newVal) {
                    self._data[key] = newVal
                }
            })
        })
    }

    /**
     * 初始化 watch
     */
    _initWatch() {
        let self = this
        let watch = this.$options.watch
        Object.keys(watch).forEach(key => {
            new Watcher(self, key, watch[key])
        })
    }
}

```

`Compile.js`：模板编译和指令解析

```js
/**
 * 模板编译类，指令解析
 */
export default class Compile {
    constructor(el, vue) {
        // vue 实例
        this.$vue = vue
        // 挂载点
        this.$el = document.querySelector(el)
        if (this.$el) {
            // fragment 是 JS 提供的虚拟节点（弱化版 AST）
            let $fragment = this.node2Fragment(this.$el)
            // 编译
            this.compile($fragment)
            // 编译后内容，上树
            this.$el.appendChild($fragment)
        }
    }

    /**
     * DOM 节点转换成 Fragment
     */
    node2Fragment(el) {
        let fragment = document.createDocumentFragment()
        let child
        while (child = el.firstChild)
            fragment.append(child)
        return fragment
    }
    /**
     * 模板编译
     */
    compile(el) {
        let self = this
        let childNodes = el.childNodes

        // 匹配 {{val}} 中 val
        let reg = /\{\{(.*)\}\}/

        childNodes.forEach(node => {
            let text = node.textContent

            if (node.nodeType === 1) {
                // console.log('是元素节点');
                self.compileElement(node)
            } else if (node.nodeType === 3 && reg.test(text)) {
                // console.log('是文本节点');
                let name = text.match(reg)[1] // 获取 {{val}} 中 val
                // console.log(`文本节点：${name}`);
                self.compileText(node, name)
            }
        })
    }
    /**
     * 编译元素
     */
    compileElement(node) {
        let self = this
        // 获取到节点的属性
        let nodeAttrs = node.attributes;
        // console.log(nodeAttrs)

        // nodeAttrs 是类数组，转成数组
        [].slice.call(nodeAttrs).forEach(attr => {
            // 例如：class="title"
            let attrName = attr.name // class
            let value = attr.value // title

            // 分析指令，都是 v- 开头的，如：v-if、v-model
            if (attrName.startsWith('v-')) { // 判断是指令
                let dir = attrName.substring(2)
                if (dir == 'model') {
                    // console.log(`v-model 指令：${value}`);
                    // 实现 v-model 的双向绑定功能
                    new Watcher(self.$vue, value, newVal => {
                        node.value = newVal
                    })

                    let v = self.getVueVal(self.$vue, value)
                    node.value = v
                    node.addEventListener('input', e => {
                        let newVal = e.target.value
                        self.setVueVal(self.$vue, value, newVal)
                        v = newVal
                    })
                } else if (dir == 'if') {
                    // console.log(`v-if 指令：${value}`);
                }
            }
        })
    }
    /**
     * 编译文本
     */
    compileText(node, name) {
        // console.log('compileText: ' + name);
        console.log(`getVueVal: ${this.getVueVal(this.$vue, name)}`);

        node.textContent = this.getVueVal(this.$vue, name)
        // 创建一个观察者，监听数据变化
        new Watcher(this.$vue, name, value => {
            node.textContent = value
        })
    }
    /**
     * 根据 a.b.c 形式的表达式从 vue 实例中获取值
     */
    getVueVal(vue, exp) {
        let val = vue
        exp.split('.').forEach(key =>
            val = val[key]
        )
        return val
    }
    /**
     * 根据 a.b.c 形式的表达式给 vue 实例设置值
     */
    setVueVal(vue, exp, value) {
        let val = vue
        exp.split('.').forEach((key, index) => {
            if (index < key.length - 1) {
                val = val[key]
            } else {
                val[key] = value
            }
        })
    }
}
```
